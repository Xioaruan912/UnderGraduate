上面其实是我们自然语言的内容 如何通过十进制转化二进制 这里机器不会通过上面的方法计算 而是快速得到结果 本节正式进入计算机内部存储

# 定点数

定点数 我们是对于 小数符号是否固定位置的

相反的是浮点数需要通过特殊记忆方法记忆

## 真值

对于机器来说 真值就是人类认识的带有 + - 符号的数字

## 机器数

机器数也就是真实存储计算机内部的数字 我们一般通过 1表示负号 0表示正号

上面我们知道了定点数的概念 下面给出定点小数和定点整数

![image-20251028193632332](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028193632332.png)

可以发现符号位一定是在小数点之前的

# 原码

我们之前学习了十进制转化二进制 在转化基础上 通过最高位表达符号 1负 0 正 其余按照绝对值存储 这就是原码

![image-20251028193746856](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028193746856.png)

这里给出 +1110 字长8位 所以我们需要扩充 填充整数高位 最高位为符号位

-1110 8位 所以我们 填充0 直到符号位写1

原码的表达范围是

![image-20251028193932833](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028193932833.png)

也就是如果有 8位字长 那么存储为 -127 ~ 127

原码包含 0 000 0000 = +0 1000 0000 = -0 

所以总数是 2^8-2

# 补码

当前计算机存储带符号的默认存储方法 主要可以快速对 加减法运算 加减法又是构建计算机的基础 所以补码很重要

正数的补码 = 原码 也就是直接转化为二进制 最高位填充 0 符号位设置为0即可

负数的补码 = 负数原码 除了符号位 其余取反 最后+1

![image-20251028194247447](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028194247447.png)

这里 +1010 和原码一样 0000 1010 表示

-1101 首先原码表示为 1000 1101 除了符号其余取反 1 111 0010 末尾+1 得到最终 补码

 1111 0011

## 无论正数还是负数 转化为对应相反数补码的方法 以及二进制快速得到真值

也就是

快速从 `[x]补` 得到 `[-x]补`

**从低位开始 找到一个1 保留👉边 左边全部取反 就可以得到相反数**

例如

0000 1100 对应真值12

第3个为字符第一个1 保留 100 取反👈全部

1111 0100 对应真值 -12

通过这个方法 我们也可以快速得到 一个补码的 真值表达式

## 补码的性质

补码 有唯一的0 所以 取值范围是

![image-20251028195108552](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028195108552.png)

-128 ~ 127 取值

也就是 只有 0000 0000 = 0 

1000 0000 我们可以通过快速求解得到结果是-128 也就是最小值 这个需要特殊记忆

0111 1111 也就是最大值 127 也需要特殊记忆

# 反码

这个只需要了解即可 是在计算机 原码转化 补码过程中生成的编码

正数 反码和原码一致

负数 是 原码转化为 补码 仅取反 不+1 就是反码

反码也有两个0

# 移码

主要是用于科学计数法的 阶数 后面的IEEE754

![image-20251028195525371](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028195525371.png)

这里偏置值是 2^ 7 也就是 1000 0000 所以结果加上 1000 0000 就是移码

1000 0000 - 0001 0101 = 0110 1011

移码的0表示唯一

真值的移码和补码只相差 符号位 补码的符号位取反得到 移码 移码的符号位取反得到补码

