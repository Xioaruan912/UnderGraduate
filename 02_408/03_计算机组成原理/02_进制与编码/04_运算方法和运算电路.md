上面学习了 考试如何手算 如何理解 有符号 无符号 原码 补码 反码 移码这些表示方法 这里进入部件 学习计算机如何 快速计算的

# 一位全加器

通过名字我们可以直到 这个部件是 1比特计算的部件 只可以输出1 bit计算结果

和逻辑为：

![image-20251028200839840](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028200839840.png)

Ci-1是上的进位 可以发现 一位全加器依赖上一个的进位

当前进位表达式是

![image-20251028200911149](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028200911149.png)

结构图如下所示

![image-20251028200927780](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028200927780.png)

但是这里我们 模糊细节

![image-20251028200940947](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028200940947.png)

408只需要了解这些内容即可

我们学习了一位的 如何把两个二进制字符串加法 

# 串行进位加法器

![image-20251028201344097](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028201344097.png)

可以计算n位 但是每一个位的计算都依赖上一个的进位结果 进位需要运算中得出 所以运算效率很慢

# 并行进位加法器

不在考研要求中 了解即可

![image-20251028201448092](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028201448092.png)

通过CLA部件 快速得到进位信息

# 带标志加法器

这里我们可以理解为串行n位加法器 但是附加了 标志效果

OF (over flag)溢出 

判断 有符号运算是否溢出（符号是否发生改变）

![image-20251028201655837](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028201655837.png)

1表示溢出 0表示没有溢出



CF (carry flag)进位

无符号运算是否溢出 0表示没有 1表示溢出

![image-20251028201740695](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028201740695.png)

SF (sign flag)正负

有符号运算结果是 正还是负 1是负 0 是正

ZF (zero flag)为0

运算结果是否为0 1是结果为0 0是结果非0

# 算数逻辑单元

运算器的核心 用于计算机的所有运算

![image-20251028201857075](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251028201857075.png)

ALUop位数 确定了 运算的模式个数 如果3位 可以有8个运算操作