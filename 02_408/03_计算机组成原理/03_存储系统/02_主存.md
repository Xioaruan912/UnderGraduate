学习完了 计算机整体存储器的大概构成 ROM RAM 还有 存取周期 下面进入 单独模块 主存

# 主存的构成

存储器通过芯片构成 一个芯片我们就看作是一个存储体

之前我们知道 ROM 和 RAM 一起构建成主存

RAM 又可以分为SRAM 和 DRAM

## SRAM

静态随机存储器

存储元我们之前知道 一个二进制位存储的物理位置就是一个存储元

如果存储元通过 双稳态触发器 构成 那么他就是SRAM SRAM具有 易失性【RAM都具有】但是其具有非破坏性读出 也就是读取后 不需要再生

SRAM一般用于构建cache

## DRAM

动态随机存储器

存储元通过 电容的电荷存储0和1

电荷会随着时间的发展 衰减 所以即使不读出 数据也会消失 所以推出了 DRAM单独的一个动作 刷新

DRAM一般用于制作主存

## 刷新

这是单独对DRAM的内容 也就是电荷衰减 所需要的刷新

刷新周期：两个刷新动作 执行的中间时间

### 集中刷新

一个刷新周期中 我们使用一个固定的时间片 这个时候存储元不允许 读取或者写入 只用于刷新 这个时间我们也叫做死区

### 分散刷新

这里不对刷新周期了 而是对一个存储系统 他的工作周期 直接划分为两个 一个读取时间 一个刷新时间

![image-20251029153538127](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029153538127.png)

可以发现 其实是把系统时间延迟 让OS认为读取就是花费1us 但是实际上0.5us就读取完毕了 后面0.5用于刷新

### 异步刷新

综合了前面两个方法 一个刷新周期 一行只刷新一次

通过刷新周期除以行数 得到相邻两行之间的刷新间隔 这个时候 每ts就会执行一次刷新 让死时间分散开

## 刷新和再生

需要清晰理解刷新和再生的概念

在破坏性读出的时候 需要再生操作

即使不读写 随着时间 电荷衰减 需要刷新操作 保证数据不消失 这就是刷新操作

# DRAM的地址引脚复用技术

我们知道RAM可以通过 地址唯一确定 存储单元 时间上是通过 芯片的X Y轴确定 通过传输X轴Y轴 可以确定唯一单元

引脚复用技术就是 X Y轴通过 一个引脚传入 而不再分为X引脚和Y引脚 减少引脚数

# DRAM 芯片的行列优化

我们希望 芯片的列数大于等于行数 这样每次刷新 CPU等待时间就减少

所以 芯片的行列数 满足 |行-列|最小 和 行<=列

![image-20251029154223607](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029154223607.png)

# DRAM行缓冲器

![image-20251029154251793](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029154251793.png)

DRAM如图所示

通过地址线 和地址引脚复用技术 可以实现 分次传入 2位地址 确定存储单元

例如 第一次传入10 = 2确定行 第二次传入 01=1 确认列 （2，1）得到存储元后通过行缓冲器 缓存 读取行的每一列 也就是存储1列的数据 这样每个时钟 都可以连续输出 

这样就实现了突发传输

# SDRAM

SDRAM实际在DRAM上添加了一个 时钟信号 通过时钟扩展 协调操作

![image-20251029154639403](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029154639403.png)

也就是之前CPU需要等待存储器读取完毕后 才可以进行其他操作 但是加入时钟后 分离开了

# 存储器内部结构

一个存储器如图所示

![image-20251029154815470](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029154815470.png)

地址寄存器我们认为是MAR寄存器

MAR输入到X Y译码器后 会得到自己XY的行列数 这样就可以读取单元

存储矩阵是通过DRAM或者其他芯片组合成的大芯片

片选是如果存储体是通过多个芯片组合 那么就需要片选信号唯一指定

# ROM

只读存储器 我们需要学习分类

## 掩模式只读存储器

MROM 这是用户不可写的存储器 商家在生成过程中直接写入程序

## 一次可编程只读存储器

PROM 可以通过专用设备 修改程序一次

## 可擦除可编程只读存储器

EPROM 用户可以通过编程器 写入程序 但是不可以替代RAM 因为写入时间长 写入速度又很慢

## Flash存储器

在EPROM上发展的 兼容ROM和RAM的优点

可以在不加电情况下长期保存 类似U盘

## SSD

固态硬盘 基于Flash存储器发展 

# 主存储器的构成

![image-20251029155422405](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029155422405.png)

# 多模块存储器

通过 空间并行技术 实现多个存储模块一起 这样在存储周期的恢复时间 CPU依旧可以读取

## 单体多字存储器

这里没有用到空间并行 也就是输入一个地址 连续输出多字 每个存储周期 都输出 1个指令

![image-20251029155732263](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029155732263.png)

## 高位交叉编制存储器

这里虽然使用了多模块 但是没有达到存储速度提升

![image-20251029155814924](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029155814924.png)

这里给出4个模块 那么CPU给出存储地址的高2位 就可以唯一确定模块数

例如 0100 0001 可以看作 01模块的 00 0001地址

那么我们知道 如果一个程序连续读书 那么一定是按照 0100 0001 下一个 0100 0002

可以发现都是在01模块 那么每个模块读取完毕后 存储周期都有一个恢复周期 所以CPU依旧需要等待 恢复周期结束后 才可以读取

速度没有提升

## 低位交叉编制

这里就是提升的方法 通过低位确定模块 高位确定地址 从而实现 流水线工作

![image-20251029160046789](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029160046789.png)

0000 0001 代表 1号模块的0000 00地址

0000 0002 代表 2号模块的0000 00地址 这个时候1号模块在恢复阶段

可以发现 很好规避了 恢复阶段 效率提升

### 轮流启动方法

轮流启动也就是我上面给出的方法 通过地址变化 轮流启动不同模块

如果要实现流水线 那么模块个数M 需要大于或者等于 一个模块存储周期T/总线周期r

这样如果按照1/M个存储周期启动模块 那么每个1/M都可以读取一个数据

如果保证 m*r 后再次启动 就可以保证流水线按 如果按照流水线工作 那么连续读取m个字的时间为

![image-20251029160407740](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029160407740.png)

存储图如下

![image-20251029160423352](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029160423352.png)

### 同时启动

如果所有模块 一次读写 的数据位数和总线数据位大小相同 那么需要一次启动所有模块

![image-20251029160528001](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251029160528001.png)