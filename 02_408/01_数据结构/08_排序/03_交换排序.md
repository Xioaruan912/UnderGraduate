- # 交换排序是什么 交换排序的算法有什么

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">交换排序 是按照两个元素在序列中的大小 进行交换相对位置 每次交换的是两个元素</li>
    <li style="color: blue;">交换的算法有：冒泡排序和快速排序 </li>
    </ul>
  </details>

- # 冒泡排序的算法思想 算法执行过程 时空复杂度分析

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">冒泡排序 思想是 从后向前 把最后一个元素 和前一个元素 比较 如果小 就交换  然后再把倒数第二个和之前的比较 直到比较完毕 这样可以唯一确定一个最小元素 也就是每一趟都可以确定一个最小元素  类似冒泡 每次比较 前面已经确定位置的元素 不再比较</li>
    <li style="color: blue;">最多n-1趟 就可以排序完毕</li>
    <li style="color: blue;">冒泡排序 没有使用到外部空间 空间复杂度为O(1) 最好情况下 时间复杂度为 O(n) 最坏情况下 完全逆置 时间复杂度达到 O(n^2) 冒泡排序是一个稳定的算法</li>
    </ul>
  </details>

- # 快速排序的算法思想 算法执行过程  快速排序二叉树描述 时空复杂度分析 如何降低快排的时间复杂度 快速排序在所有内部排序算法中的地位

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">快速排序的想法是 在 待排序序列中 任意选择一个元素 作为 基准 通过一趟排序 就可以得到两个部分的 要求 左边均小于 基准 右边均大于等于基准 那么这个时候 基准元素就会被唯一确定到位置上 然后依旧对两个子序列 使用快速排序 即可得到有序序列</li>
    <li style="color: blue;">快速排序执行过程： 一般通过两个指针i和j指向 第一个元素和最后一个元素 并且pivot指针指向当前基准元素 首先从high找到第一个小于 pivot元素的 然后和 i指针交换位置  切换i指针向后查找第一个大于 pivot指针的元素和j交换 依次执行 直到 i=j 这样就可以使 i==j 之前的元素均小于 pivot 后面均大于pivot 后面对分开独立的两个序列 再次进行快速排序</li>
    <li style="color: blue;">可以使用二叉树描述 快速排序算法</li>
    <li style="color: blue;">快速排序 需要使用栈作为 递归的保存 空间复杂度为O(log2^n) 时间  最坏情况下 时间复杂度达到 O(n^2) </li>
    <li style="color: blue;">如果 基准元素选择的是可以让序列均分的 就可以降低时间复杂度 或者随机选 一般情况都不会达到最坏时间复杂度</li>
    <li style="color: blue;">快速排序算法是 内部排序中最优的算法 但是快速排序是一个不稳定的排序算法 并且只适用于 顺序存储的顺序表适用</li>
    </ul>
  </details>