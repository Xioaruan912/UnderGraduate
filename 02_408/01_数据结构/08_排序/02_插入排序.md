- # 插入排序是什么 插入排序的算法有什么
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">插入排序是 一个简单直观的排序算法 把每一次需要排序的记录 按照关键字大小 插入到前面已经有序的序列中 </li>
    <li style="color: blue;">插入排序的算法有：直接插入排序 折半 插入排序 希尔排序 </li>
    </ul>
  </details>

- # 直接插入排序的算法思想 算法执行过程 时空复杂度分析
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">直接插入排序对序列分为3块 【已经排序的序列】【当前比对的元素】【还没有排序的序列】 </li>
    <li style="color: blue;">直接插入排序执行过程： 首先按照 当前比对的元素 查找 在已经排序的序列中的应该插入的位置k【如果元素相同 相对位置不变】 然后把已经排序的序列 全部后移1位 替换 当前比对的元素和 k位置元素值 实现排序</li>
    <li style="color: blue;">我们一般使用哨兵 存储 当前需要比对的元素 这样也可以保持 位序的不变</li>
    <li style="color: blue;">直接插入排序 没有使用到外部空间 空间复杂度为O(1) 最好情况下 时间复杂度为 O(n) 最坏情况下 完全逆置 时间复杂度达到 O(n^2)</li>
    </ul>
  </details>

- # 折半插入排序的算法思想 算法执行过程 时空复杂度分析
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">如果排序序列存储为 顺序表 可以通过折半查找 快速确定 插入位置 也就是在直接插入排序的第一步 加快速度 因为前面是已经排序完毕的序列 </li>
    <li style="color: blue;">折半插入排序执行过程： 通过折半查找 快速定位 k  后面和直接插入算法一致  所以是稳定的算法</li>
    <li style="color: blue;">折半插入排序 没有使用到外部空间  最坏情况下 完全逆置 时间复杂度达到 O(n^2) 但是如果数据量不大 折半优于直接插入算法</li>
    </ul>
  </details>

- # 希尔排序的算法思想 算法执行过程 时空复杂度分析
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">直接插入算法 如果有序 那么效率就是O(n) 希尔排序就是通过这个思想 改进的 也叫做缩小增量排序 </li>
    <li style="color: blue;">希尔排序执行过程： 约定d 并且d小于n 把表中的所有元素 分为d组 所有距离为d的存放在一组 并且在每组内进行直接排序算法 然后取第二个d2 &lt; d 继续执行上述算法 直到d = 1 这个时候 序列基本有序 再次进行一次直接插入排序 就可以确保有序  </li>
    <li style="color: blue;">距离 是本位置+d后的元素</li>
    <li style="color: blue;">希尔排序 没有使用额外的存储空间 空间复杂度为O(1) 但是时间复杂度难以分析 我们认为最坏情况下时间复杂度为O(n^2) 希尔排序在分组过程中 会导致 相同的元素 改变相对位置 所以是一个不稳定的算法 并且他只适用于 顺序存储</li>
    </ul>
  </details>
