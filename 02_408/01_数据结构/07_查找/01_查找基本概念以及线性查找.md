- # 查找的基本概念 平均查找长度

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">在一个有限序列中 查找某个满足条件的过程就是查找</li>
    <li style="color: blue;">一次查找 需要比较关键字的次数 P是找到的概率 我们一般设置为 1/n 找到元素C为比较的次数 计算公式为 求和（Pi * Ci) 就是整个序列平均查找长度</li>
    </ul>
  </details>

- # 顺序查找 哨兵是什么 定位第i个元素的时候 需要进行多少次比较 平均查找长度 有序线性表的顺序查找

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">顺序查找也就是最简单的查找 如果是顺序存储 那么就按照数组下标查找 如果是链表 那么就next查找 依次对比每个元素 直到结束 我们可以设置 数组0 或者头节点为 哨兵 这样次序和位序就一致了 避免了许多判断语句 </li>
    <li style="color: blue;">顺序查找 定位到第i个元素 需要进行 n-i+1次的比较 </li>
    <li style="color: blue;">每个元素概率均为 1/n 那么 ASL(平均查找长度)=求和1/n * n-i+1  = n+1/2</li>
    <li style="color: blue;">如果线性表语句有序了 那么找到某个元素 只要小于 并且 i+1 大于 就可以判断查找失败了 可以使用二叉树来分析 查找失败一定是到了叶子节点中</li>
    </ul>
  </details>

- # 折半查找 折半查找判定树 平均查找长度

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">对于 int类型的 有序 线性表 可以通过 折半查找方法 快速查找 类似 SQL注入 折半计算ASCII【不适用链表】</li>
    <li style="color: blue;">首先设定 mid 为 high + low /2 如果 mid =key 直接返回 如果 data[mid] &gt; key (说明不会出现在右边了) 那么就把 high = mid - 1 重新计算 else （也就是不会出现在左边） 那么 low = mid+1 重新计算 </li>
    <li style="color: blue;">这里 /2 可以采用向下取整 也可以采用向上取整 mid low high 均为序号 </li>
    <li style="color: blue;">通过构建折半查找判定树 也可以快速分析 折半查找的判定树是一个平衡二叉树 也就是左右高度不超过1 n个节点 n+1个叶子 </li>
    <li style="color: blue;">折半查找 的平均查找长度也就是 判定树的树高 最多不会超过 我们认为 向上取整[log2^n+1]</li>
    </ul>
  </details>

- # 分块查找 最小查找长度是怎么取

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">吸取了顺序查找和折半查找的优先 我们也叫做 索引顺序查找</li>
    <li style="color: blue;">把整个序列分块 块内无序按照 块间有序 选择的块关键字 应该是子块中最大字</li>
    <li style="color: blue;">如果 长度为n 每块内有 根号(n) 那么这个时候 平均查找长度最小 </li>
    </ul>
  </details>