- # 散列如何查找的 冲突是什么

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过一个f 和关键字 直接计算得到地址 这就是散列查找 如果有不同关键字 但是通过一个f 计算到一个地址上 就导致了冲突 hash算法应该避免发生冲突 并且还需要设计发生冲突后如何操作 理想的散列查找 时间复杂度 o(1)</li>
    </ul>
  </details>

- # 不同的散列函数 直接定址法 除留余数法 数字分析法 平方取中法

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">直接定址法：hash(key)= key 或者 key*a +b  适合关键字连续分布 如果不连续 那么可能会导致空间存在大量碎片</li>
    <li style="color: blue;">除留余数法：hash = key % p 通过这个计算方法 可以让关键字等概率分布 从而减少冲突 </li>
    <li style="color: blue;">数字分析法：分析数字出现个数 多个数字经常出现 那么就应该选择 分布均匀的 并且这个方法需要对不同关键字分析</li>
    <li style="color: blue;">平方取中法：也就是多个字符串取中间字符作计算关键字</li>
    </ul>
  </details>

- # 处理冲突的方法 开放定址法:线性探测法 平方探测法 双散列探测法 伪随机探测法 拉链法
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过上面的hash函数 可以得到确定的地址 但是说过了 地址存在冲突 所以如何处理冲突 存在下面的方法</li>
    <li style="color: blue;">开放定址法：定义表中空闲的区域 可以对计算地址 也可以对发生冲突的内容开放 Add = (Hash(key)+di)%m m表示存储长度 d表示递增序列 对于递增序列 存在下面的方法</li>
    <li style="color: blue;">线性探测法： 也就是d 是线性增加的 直到找到一个空闲的 但是这个方法会导致 大量数据囤积 聚集在一起</li>
    <li style="color: blue;">平方探测法： k^2 并且 k是 +1 -1 +2 -2 取值的 散列长度 必须是 4k+3的素数 缺点是不能探测到全部单元  </li>
    <li style="color: blue;">双散列探测法：通过两个hash函数 如果第一个发生冲突 那么使用第二个hash函数计算增量地址 (H1(key) + i*H2(key))%m i是发生冲突的次数 初始为0</li>
    <li style="color: blue;">伪随机探测法：di是一个伪随机数列</li>
    <li style="color: blue;">拉链法：使用拉链法 计算hash得到唯一地址 如果冲突 使用链表存储 这样不需要再次寻找 只需要遍历链表 即可确定数据</li>
    </ul>
  </details>

- # 散列表查找效率影响因素是什么 装填因子是什么

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">散列表查找效率取决于 散列函数 处理冲突的方法 和 装填因子</li>
    <li style="color: blue;">装填因子我们记作a 一般是定义为表的装满程度 a=表中记录个数n / 散列表长度m </li>
    <li style="color: blue;">平均查找长度依赖于散列表的装填因子a 不直接依赖于n和m 也就是a越大 表示记录越多 冲突概率越大 反之越小</li>
    </ul>
  </details>