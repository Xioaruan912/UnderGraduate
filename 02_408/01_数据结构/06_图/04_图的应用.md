- # 图的应用考察什么东西

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">最小生成树 最短路径 拓扑排序 关键路径</li>
    </ul>
  </details>

- # 最小生成树：生成树是什么 最小生成树是什么 最小生成树的性质 最小生成树确定的内容是什么 能不能确定两个点之间最短

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">生成树：如果一个图的生成树 需要包含全部节点 以及最少的边 如果砍去一个边 退化为非连通 如果增加一条边 会出现回路</li>
    <li style="color: blue;">最小生成树：对于带权连通无向图 每个边的权不同 那么权值最小的 就叫做 最小生成树</li>
    <li style="color: blue;">最小生成树的性质：如果树的权有多个相同的边 那么最小生成树不唯一 如果图的每个边权都不一样 则唯一 如果连通无向图的边比节点少一 那么他就是最小生成树了 最小生成树的边比顶点少1</li>
    <li style="color: blue;">最小生成树 确定 这个生成树的权值和一定是图中最小的 但是不一定 两个节点之间的权是最小的 无保障</li>
    </ul>
  </details>

- # 最小生成树的算法：Prim算法（普利姆）Prim算法的性质 Kruskla算法

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">Prim算法：首先给出的图可能有多个回路 那么我们首先任取一点 加入树 然后选择与当前节点距离最近的节点 如此往复 直到所有节点都进入树了 这个时候 T必然有n-1个边 【当下最优】</li>
    <li style="color: blue;">Prim算法 适合边稠密的图 并且他的时间复杂度为 O(v^2) 不依赖边</li>
    <li style="color: blue;">Kruskla算法：把 边的权值 从小到达排序 依次把从小到达的两个节点组合 直到所有节点都连接起来了</li>
    <li style="color: blue;">Kruskla算法 适合边稀疏而顶点多的图 并且他的时间复杂度为 O(Elog^2E) 不依赖顶点</li>
    </ul>
  </details>

- # 最短路径：什么是最短路径 使用什么算法

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">两个节点经过的权可以代表他们的距离 也就是经过距离最小的序列 就是两个点之间的最短路径</li>
    <li style="color: blue;">对于求解 一个点到其他点的最短路径 可以使用Dijkstra算法 如果求解任意两个顶点的最短路径 使用 Floyd算法</li>
    </ul>
  </details>

- # 最短路径算法：Dijkstra算法 性质 Floyd算法【没看懂】 性质
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">Dijkstra算法：求解的是一个节点到达其他任意节点之间的最短路径 是基于贪心算法的</li>
    <li style="color: blue;">Dijkstra算法过程：列出所有点到该点的距离（权值） 把距离最小的加入集合中  第二轮去除 第一轮选走的点 估计从 v1->v5(假设第二个选走的是v5)->Vn 的距离 然后选走最小权和的 第三次 继续 v1->v5->v3->vn 找全和最小的 【如果v3没有到达其点的路径 就去找v5到达v3到达不到的点 如此往复】 就可以最终得到一个集合S和最短路径</li>
    <li style="color: blue;">Dijkstra算法性质：时间复杂度O(v^2) 并且如果边上有权值为负数 那么 Dijkstra算法失效</li>
    <li style="color: blue;">Floyd算法：求解所有顶点之间的最短路径</li>
    <li style="color: blue;">Floyd算法：维护一个 邻接矩阵方阵 </li>
    <li style="color: blue;">Dijkstra算法性质：时间复杂度O(v^2) 并且如果边上有权值为负数 那么 Dijkstra算法失效</li>
    </ul>
  </details>

- # 有向无环图：什么是DAG 为什么提出这个
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">如果一个有向图 不存在环 就是有向无环图 叫做DAG图</li>
    <li style="color: blue;">通过有向无环图 可以快速把一个乘积式子构建 生成树 这样存储内容就比二叉树的 乘积小了</li>
    </ul>
  </details>
  
- # 拓扑排序：AOV是什么 拓扑排序是什么 构建拓扑排序 不同存储的时间复杂度 DFS 逆拓扑排序
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">如果一个 有向无环图表示工程 节点表示活动 边表示关系 那么这个图我们叫做AOV网</li>
    <li style="color: blue;">AOV网中 前驱和后继具有传递性 任何活动不能是自己的前驱或者后继</li>
    <li style="color: blue;">每个节点只出现依次 并且 如果顶点A在顶点B的前面 那么不存在 从B到A的序列的 排序 我们叫做拓扑序列 每个AOV网都有一个或者多个拓扑序列</li>
    <li style="color: blue;">选择一个顶点 选择可以入度为0的节点 输出并且删除 顶点和以他为弧尾的所有边（指向别人的）</li>
    <li style="color: blue;">按照 邻接表存储的时候 时间复杂度为O(E+V) 邻接矩阵存储的时候 时间复杂度为O(V^2)</li>
    <li style="color: blue;">通过DFS算法 也可以构建一个拓扑排序</li>
    <li style="color: blue;">构建一个逆拓扑排序：选择一个没有出度的节点 输出删除 并且删除所有指向本节点的边 直到AOV空</li>
    </ul>
  </details>
  
- # 关键路径：AOE网是什么 性质 源点汇点是什么  关键路径是什么 如何构建关键路径 提升时间
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">带权有向图中 顶点表示事件 边表示活动 权表示消耗的时间 那么这个图就是代表消耗时间的活动 我们叫做AOE网 和AOV网都是有向无环图 但是表达的含义不同 AOE有权值 AOV无权值 只表示先后关系</li>
    <li style="color: blue;">AOE网的性质： 只有顶点的事件发生后 从本顶点出发的其他 事件才允许被执行 只有进入本节点的其他时间都结束了 本节点才允许执行</li>
    <li style="color: blue;">每个AOE 都有一个 入度为0 我们叫做源点 出度为0叫做汇点</li>
    <li style="color: blue;">AOE网中 从源点到汇点的路径有多条 具有最大路径长度的 我们叫做关键路径 路径上的活动 叫做关键活动</li>
    <li style="color: blue;">完成整个活动的最短时间就是关键路径的长度</li>
    <li style="color: blue;">首先对图进行 拓扑排序 并且我们填入表的是 最大长度 这个表我们叫做 从源点出发的其余顶点最早发生时间</li>
    <li style="color: blue;">得到的拓扑排序最后一个汇点元素值 写入新的表 按照逆拓扑排序 开始执行 把汇点到其余顶点的消耗时间最长的写入表中 我们叫做 汇点到其余顶点的 最迟发生时间</li>
    <li style="color: blue;">构架每个边的最早时间 弧的弧尾的从源点出发的其余顶点最早发生时间表 写入 构建所有边</li>
    <li style="color: blue;">构架每个边的最迟时间 弧的弧头的从汇点到其余顶点的 最迟发生时间表 写入 构建所有边</li>
    <li style="color: blue;">最后把后面两个相减 得到一个值 如果值=0 说明就是这个项目的关键路径按照=0 的边连接起来的顶点 就是关键活动</li>
    <li style="color: blue;">如果只是对 某一个路径提升时间 有可能会在缩减时间后 转化为非关键路径了 如果我们希望缩减时间 应该是对包括在关键路径上的所有关键活动 才可以缩减成功</li>
    </ul>
  </details>