- # 图的遍历是干嘛 遍历的方法

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">我们希望从一个顶点出发 按照某种方法 可以对图的所有节点访问一次 并且仅访问一次</li>
    <li style="color: blue;">存在两个方法 一个是广度优先算法BFS 一个是深度优先算法DFS</li>
    </ul>
  </details>

- # 图的广度优先算法 BFS的性能 求解单源最短路径 BFS优先生成树

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">有点类似 树的层序遍历 也就是先把当前节点的连接顶点先遍历 然后再访问连接节点的没有访问过的连接节点</li>
    <li style="color: blue;">如果一次BFS结束后 还有节点没有访问 那么就对这个节点 再进行一次BFS算法</li>
    <li style="color: blue;">BFS 空间复杂度是O(V) 通过邻接表访问的时候 时间复杂度为O(V+E) 通过邻接矩阵访问的时候 时间复杂度为O(V^2)</li>
    <li style="color: blue;">用于BFS找到两个节点之间的最短路径</li>
    <li style="color: blue;">遍历过程中 我们会得到一个遍历树 邻接矩阵存储唯一 所以遍历树唯一 邻接表不唯一 所以遍历树不唯一 需要看存储结构是什么</li>
    </ul>
  </details>

- # 图的深度优先 DFS的性能 求解单源最短路径 BFS优先生成树

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">深度优先算法我们叫做DFS 访问起始顶点后 通过v 访问当前没有访问的连接节点 然后再找当前没有访问的连接节点的连接节点 一直找到没有 没有访问的了 然后依次往回看看 还有没有没有访问的 </li>
    <li style="color: blue;">DFS 空间复杂度是O(V) 时间复杂度通过邻接表是O(V+E) 邻接矩阵是O(V^2)</li>
    </ul>
  </details>

- # 图的临界多重表

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">有点类似十字链表 但是用于解决无向图问题 边节点（ivex,ilink,jvex,jlink,info) ivex和jvex用于表示这个边连接的两个节点编号 ilink jlink用于表示依附ivex和jvex的下一边节点 info表示权 节点(data,firstedge) data表示数据 firstedge表示本节点第一个边</li>
    </ul>
  </details>