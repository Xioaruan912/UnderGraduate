- # 队列是什么 队尾 队头是什么 队列的存储结构有什么

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">也是一个输入输出受限的线性表 他主要是只允许一端插入 另一端输出 呈现 先进先出 的算法</li>
    <li style="color: blue;">队尾也就是允许插入的地方 队头是允许输出的地方</li>
    <li style="color: blue;">队列有 顺序存储和链式存储队列</li>
    </ul>
  </details>

- # 队列的顺序存储 结构体是什么 如何插入元素和出队元素 队列空 上溢出

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过连续数组 存储一个队列 并且设定两个指针 front 和rear 分别指向队头和队尾 </li>
    <li style="color: blue;">插入元素的时候 类似栈 但是我们是修改 rear指针 也就是队尾不断增加 插入  出队元素 是修改front指针 如果 +1 就出队一个元素</li>
    <li style="color: blue;">front == rear 就代表队列空</li>
    <li style="color: blue;">在队列中 如果每次 插入后立马出队 那么不断这样 就会导致 front = MAXSIZE -2 ; rear = MAXSIZE - 1 这个时候队列中只有一个元素 导致浪费空间 并且无法判断队列是否满 所以提出了循环队列</li>
    </ul>
  </details>

- # 循环队列 初始化 插入元素 出队元素 计算长度 判断队列空 牺牲一个存储单元区分 增加size数据成员 添加tag数据成员

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">依旧是队列的顺序存储 只是对指针的判别 存在逻辑上的循环 </li>
    <li style="color: blue;">规定 rear=front代表当前初始化 也就是队列空</li>
    <li style="color: blue;">插入元素按照  (rear +1 ) %MAXSIZE 得到 按照之前的例子 如果rear当前在 MAXSIZE -1 那么通过这个计算下一个应该是在0的 之前我们说front是在MAXSIZE-2 故 0当前是没有元素的 可以插入 这样就实现了一个 物理上不是循环的 逻辑上组成一个环  </li>
    <li style="color: blue;">出队操作也是 (front + 1)%MAXSIZE 上面同理  </li>
    <li style="color: blue;">计算队列当前长度 为 (rear + MAXSIZE - front ) %MAXSIZE 为了减法得到正数 所以rear无论多大 首先加上 MAXSIZE 得到结果后 mod MAXSIZE 即可得到当前队列长度 没啥好说的记下就可以了  </li>
    <li style="color: blue;">判断队列空 ： 我们之前说了 Q.rear == Q.front 就代表队列空 但是如果rear的插入非常多 那么在堆满的情况也会有 rear=front 所以对于队列满 我们需要特殊情况判断</li>
    <li style="color: blue;">牺牲一个存储单元区分 ： 我们要求 每次插入都要保证不允许使用队列最后一个元素 这个时候判断队列空 就是 rear==front 判断队列满就是 (rear+1)%MAXSIZE == front </li>
    <li style="color: blue;">增加size数据成员 ：结构体中添加size成员 用于记录当前队列元素个数 插入一个元素 +1 推出一个元素 -1 队列空则是 size ==0 队满是 Q.rear == Q.front </li>
    <li style="color: blue;">添加tag数据成员 ：结构体添加tag成员 用于记录当前的成功操作 如果成功删除元素 tag设置0 成功插入元素 tag设置1 通过tag是0 还是1 区分 rear==front的时候是 空的 还是满的 </li>
    </ul>
  </details>

- # 队列的链式存储是什么 入队 出队

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过多个节点和指针连接起来的队列 分布可能离散的 并且不存在上溢 可以动态申请空间</li>
    <li style="color: blue;">rear指向链尾 每次入队都需要修改rear到最后一个元素</li>
    <li style="color: blue;">front指向链头 每次出队 首先需要判定当前队是否位空 如果节点是最后一个元素 rear和front都应该设置为NULL（不带头节点）</li>
    </ul>
  </details>
  
- # 双端队列 如何解题

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">如果对队列的约束放开 允许在 双端插入 一端输出 或者一端插入 双端输出 就变为了双端队列</li>
    <li style="color: blue;">做这个题目的时候 尝试就可以了</li>
    </ul>
  </details>