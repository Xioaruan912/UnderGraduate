- # 栈是什么 栈顶 栈底是什么 插入顺序 栈的存储结构有什么

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">一种 输入输出受限的线性表 要求只能在某一端插入 或者删除</li>
    <li style="color: blue;"> 栈顶 内存中为低地址的那个 记为top 一般是 指向栈顶元素 也有可能指向栈顶元素+1  栈顶是允许插入的那一端</li>
    <li style="color: blue;"> 栈底 内存中为高地址的那个 记为Bottom 如果栈顶是 指向栈顶元素 那么栈底指向的是最后一个元素-1 如果栈顶指向栈顶元素+1 那么栈底指向第一个插入元素的位置 栈底是不允许插入的那端</li>
    <li style="color: blue;">栈的插入逻辑是 先进后出 也就是 依次插入 2345 那么出栈就是 5432</li>
    <li style="color: blue;">栈的存储结构有 顺序栈和链栈</li>
    </ul>
  </details>

- # 顺序栈的定义 结构体是什么 栈空和栈满的条件 入栈 出栈的便捷代码 上溢

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过一组地址连续的存储空间 存放 栈底到栈顶的元素</li>
    <li style="color: blue;">一般结构体包含两个元素Elemtype data[MAXSIZE]; int top;</li>
    <li style="color: blue;">初始化的时候 top指向的是 -1 入栈操作就是 先+1 再插入 如果初始化指向 0 那么就是先插入后+1</li>
    <li style="color: blue;">如果 top = -1那么就是栈空 如果 top = MAXSIZE -1 那么就是栈满</li>
    <li style="color: blue;">S.data[++S.top] = x 这就是先加后插入 Elemtype x =S.data[S.top--]  这就是先取再减 （这里默认从 top初始为-1，0的情况和这个不一样 但是可以分析出来 S.data[S.top++]=x ; x = S.data[--S.top]) </li>
    <li style="color: blue;">顺序栈是声明好的一片存储空间 如果超过了预设的区域 就溢出 </li>
    </ul>
  </details>

- # 共享栈的定义是什么 两个栈底从什么开始 栈满的判断是什么

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">由于栈的一方面受限 那么如果我们的栈空间很大 可以存储两个栈 实现组合为共享栈 如果存储空间从 0到n-1</li>
    <li style="color: blue;">栈A的栈底就是从0开始 栈B的栈底就是从n-1开始 两个都有栈顶指针</li>
    <li style="color: blue;">每次插入的时候 都先判断 如果 topB-topA = 1 说明栈满了不能存储了  </li>
    </ul>
  </details>

- # 链栈是什么 通过什么实现 有没有头节点 在哪里操作

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过多个节点和指针连接起来的栈 分布可能离散的 并且不存在上溢 可以动态申请空间</li>
    <li style="color: blue;">链栈默认通过 单链表实现 并且不设有头节点 所有操作都在表头</li>
    </ul>
  </details>
