- # 串是什么 子串 串相等 空格在串内的地位 截断 串长的隐含表示 堆分配

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">用于存储字符 处理字符数据的数据结构 基本格式类似 'a1a2a3' n为字符个数 n=0为空串</li>
    <li style="color: blue;">如果 长度相同 并且 对应位置字符相同 那么串相等</li>
    <li style="color: blue;">空格也是一个字符 所以占串的一个</li>
    <li style="color: blue;">如果输入一个长度大于存储的字符串 那么就会被截断 也就是超过MAXSIZE的会直接被删除</li>
    <li style="color: blue;">如果结构体中不设有串长 那么在字符串末尾 加上 \0 就代表这个串的结束 下一个串的开始 这样就隐含内部了</li>
    <li style="color: blue;">在堆中存储不变量 跳过 malloc和free分配堆空间</li>
    </ul>
  </details>

- # 串的链式表示 块链

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">可以把一个字符 按照链表的方法构建  也可以通过存储多个字符在一个data中 实现块链 如果某个固定长度块链不够 通过#填充即可</li>
    </ul>
  </details>

- # 循环队列 初始化 插入元素 出队元素 计算长度 判断队列空 牺牲一个存储单元区分 增加size数据成员 添加tag数据成员

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">依旧是队列的顺序存储 只是对指针的判别 存在逻辑上的循环 </li>
    <li style="color: blue;">规定 rear=front代表当前初始化 也就是队列空</li>
    <li style="color: blue;">插入元素按照  (rear +1 ) %MAXSIZE 得到 按照之前的例子 如果rear当前在 MAXSIZE -1 那么通过这个计算下一个应该是在0的 之前我们说front是在MAXSIZE-2 故 0当前是没有元素的 可以插入 这样就实现了一个 物理上不是循环的 逻辑上组成一个环  </li>
    <li style="color: blue;">出队操作也是 (front + 1)%MAXSIZE 上面同理  </li>
    <li style="color: blue;">计算队列当前长度 为 (rear + MAXSIZE - front ) %MAXSIZE 为了减法得到正数 所以rear无论多大 首先加上 MAXSIZE 得到结果后 mod MAXSIZE 即可得到当前队列长度 没啥好说的记下就可以了  </li>
    <li style="color: blue;">判断队列空 ： 我们之前说了 Q.rear == Q.front 就代表队列空 但是如果rear的插入非常多 那么在堆满的情况也会有 rear=front 所以对于队列满 我们需要特殊情况判断</li>
    <li style="color: blue;">牺牲一个存储单元区分 ： 我们要求 每次插入都要保证不允许使用队列最后一个元素 这个时候判断队列空 就是 rear==front 判断队列满就是 (rear+1)%MAXSIZE == front </li>
    <li style="color: blue;">增加size数据成员 ：结构体中添加size成员 用于记录当前队列元素个数 插入一个元素 +1 推出一个元素 -1 队列空则是 size ==0 队满是 Q.rear == Q.front </li>
    <li style="color: blue;">添加tag数据成员 ：结构体添加tag成员 用于记录当前的成功操作 如果成功删除元素 tag设置0 成功插入元素 tag设置1 通过tag是0 还是1 区分 rear==front的时候是 空的 还是满的 </li>
    </ul>
  </details>

- # 队列的链式存储是什么 入队 出队

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">通过多个节点和指针连接起来的队列 分布可能离散的 并且不存在上溢 可以动态申请空间</li>
    <li style="color: blue;">rear指向链尾 每次入队都需要修改rear到最后一个元素</li>
    <li style="color: blue;">front指向链头 每次出队 首先需要判定当前队是否位空 如果节点是最后一个元素 rear和front都应该设置为NULL（不带头节点）</li>
    </ul>
  </details>

- # 双端队列 如何解题

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">如果对队列的约束放开 允许在 双端插入 一端输出 或者一端插入 双端输出 就变为了双端队列</li>
    <li style="color: blue;">做这个题目的时候 尝试就可以了</li>
    </ul>
  </details>