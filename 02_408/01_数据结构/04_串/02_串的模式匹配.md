- # 模式串是什么 最简单模式匹配

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">模式串： 是用户给出的一个串 在主串中查找这个字串 如果有就返回第一个字符位置 否则 返回没有 这也就是模式匹配</li>
    <li style="color: blue;">最简单模式匹配：通过暴力检索 首先找到字符相同的 然后开始匹配子串 如果相同 双指针向后移动 否则 模式串回到 1 也就是第一个字符 主串指针返回到 i-j+2 （刚刚匹配子串的下一个字符）</li>
    <li style="color: blue;">暴力检索时间复杂度为 O(nm) n为主串长度 m为模式串长度</li>
    </ul>
  </details>

- # 为什么提出KMP算法 前缀 后缀 部分匹配值 通过ababa举例

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">在简单暴力算法之下 我们发现 如果主串的子串是 abcd 模式串为 abce 那么i=4 j=4的时候 发现d和e不匹配 下一个匹配的字串为 bcdx 我们发现 明明之前已经直到  前面abc是匹配成功的 如果下一个 肯定是不成功的 但是还是浪费了大量时间 所以提出了KMP算法</li>
    <li style="color: blue;">前缀：除了最后一个字符外 字符串所有的头部子串</li>
    <li style="color: blue;">后缀：除了第一个字符外，字符串所有的尾部子串</li>
    <li style="color: blue;">部分匹配值：字符串前缀和后缀的最长相等前后缀的长度 （都是从左往右看）</li>
    <li style="color: blue;">abcde的子串: a,ab,aba,abab,ababa </li>
    <li style="color: blue;">a的前后缀:全为空 所以匹配值为0</li>
    <li style="color: blue;">ab的前后缀:a 后缀：b 不相等 所以匹配值为0</li>
    <li style="color: blue;">aba的前后缀:a ab 后缀：a ba  可以发现 a=a 所以匹配值为1</li>
    <li style="color: blue;">abab的前后缀:a ab aba  后缀：b  ab bab  可以发现 ab=ab 所以匹配值为2</li>
    <li style="color: blue;">ababa的前缀:a ab aba abab 后缀：a ba  aba baba  可以发现 aba=aba 所以匹配值为3</li>
    <li style="color: blue;">所以我们得到 ababa字符串的部分匹配值为 00123</li>
    </ul>
  </details>

- # 部分匹配值如何作用到KMP 滑动原则 时间复杂度 如果第一个就失配了怎么办
  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">我们模式串的部分匹配值按照编号 字符和匹配值写可以得到一个PM表 </li>
    <li style="color: blue;">如果我们主串是 abcaaa 模式串ababa 我们得到了模式串的部分匹配值为00123 那么在匹配到c的时候 出错 对应的匹配值为1</li>
    <li style="color: blue;">滑动原则： 模式串右滑 = 已经匹配字符数-出错字符的匹配值 而主串的指针不移动</li>
    <li style="color: blue;">按照KMP算法 这样就是O(m+n)</li>
    <li style="color: blue;">第一个失配 那么模式串 和 主串指针 同时+1</li>
    </ul>
  </details>

- # next数组 next数组固定不变的内容 右移动细节 PM和next的关系 KMP算法在什么时候情况下比普通算法快

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">next数组存储 如果模式串的 j个字符失配 那么模式串就跳转到 next[j] 继续匹配</li>
    <li style="color: blue;">next[1] 和 next[2]都是固定为 0 1 这里不是数组下标 而是字符个数 </li>
    <li style="color: blue;">右移动： 已经匹配的【算上自己的】个数 - next[j]</li>
    <li style="color: blue;">我们可以通过前后缀快速求出PM 那么 next[j]=PM[j-1]+1 也就是我们对计算出的PM 全部 +1 并且右移动 这样就可以得到 PM对应的字符串的next数组</li>
    <li style="color: blue;">实际统计下 虽然数学展示 普通算法时间复杂度为 O(mn) KMP为O(m+n) 但是实际上 普通算法统计为 O(m+n) 所以如果模式串和子串有许多部分匹配 但是不是完全匹配的时候 才有优势</li>
    </ul>
  </details>

- # next数组的优化 nextval数组

  <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    
    <li style="color: blue;">首先通过计算 PM 得到 NEXT数组 然后我们通过NEXT数组 如果失配了 NEXT的下标对应的字符 如果与本失配字符相同 那么就填写NEXT下标对应字符的 NEXT值 并且继续匹配 如果这个时候的NEXT下标对应的NEXT值的位置的字符还是一样 那么就继续再次找到下面的 直到不相同位置</li>
    <li style="color: blue;">其实不算难 手算几下就可以了</li>
    </ul>
  </details>