- # 传输层提供的服务 
  - ## 传输层的为谁提供服务 向上提供什么样的服务
      <details>
      <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
      <ul>    <li style="color: blue;">传输层为主机上的进程提供服务</li>
      <li style="color: blue;">传输层即使数据链路是不可靠的 依旧可以向上传输可靠的服务</li>
      </ul>
      </details>


  - ## 差错检测  传输层对 哪些部分进行差错检测  TCP UDP的不同对待方式 
      <details>
      <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
      <ul>    <li style="color: blue;">传输层对收到的 首部和数据进行差错检测</li>
      <li style="color: blue;">TCP： 如果检测出错误 要求发送方重新发送</li>
      <li style="color: blue;">UDP：检测出错误那么直接丢弃</li>
      </ul>
      </details>


- # 传输层的寻址与端口 
  - ## 端口号  占的位数  FTP TELNET SMTP DNS HTTP TFTP SNMP  的端口是什么
      <details>
      <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
      <ul>    <li style="color: blue;">16bit</li>
      <li style="color: blue;">FTP： 21</li>
      <li style="color: blue;">TELNET：23</li>
      <li style="color: blue;">SMTP：25</li>
      <li style="color: blue;">DNS：53</li>
      <li style="color: blue;">HTTP：80</li>
      <li style="color: blue;">TFTP：69</li>
      <li style="color: blue;">SNMP：161</li>
      </ul>
      </details>

  - ## 套字节 格式 作用
  <details>
      <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
      <ul>    <li style="color: blue;">格式是 ip:端口</li>
      <li style="color: blue;">唯一确定某主机上的某一个进程 实现进程通信</li>
      </ul>
      </details>

- # 无连接服务和面向连接服务 
  - ## TCP 连接的基本过程  应用场合 

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;">TCP首先建立连接 传输数据 结束连接 传输过程中维持一个可靠的链路</li>
    <li style="color: blue;">TCP的 应用场合  是FTP HTTP TELNET</li>
    </ul>
    </details>

  - ## UDP 连接的基本过程  应用场合 

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;">UDP不需要建立连接 想发就发</li>
    <li style="color: blue;">TCP的 应用场合  是TFTP DNS 视频通话等</li>
    </ul>
    </details>

- # UDP数据报 
  - ## UDP 在IP层上增加了什么功能  连接时延怎么样 拥塞控制怎么样 应用场景  对报文如何操作后给IP层 

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;">添加了 复用 分用和差错检测</li>
    <li style="color: blue;">UDP是没有连接时延的 因为他不需要建立连接后传输</li>
    <li style="color: blue;">UDP是对主机的描述 也就是主机想发送就发送 对网络不在意 所以UDP发送是按照主机的意愿 无论网络是否拥塞</li>
    <li style="color: blue;">UDP适合使用在 要求时延重要性大于出错的 允许出现错误 但是要求一定要按时</li>
    <li style="color: blue;">UDP不对报文进行任何操作 添加首部后就下方给网络层 并且一次交付一个报文 报文是UDP的最小单位</li>
    </ul>
    </details>

  - ## UDP首部格式 
    - ### 源端口 多少位

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 源端口 占16位 不需要使用的时候全写0</li>
    </ul>
    </details>

 	- ### 目的端口   多少位
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 目的端口 占16位 不需要使用的时候全写0</li>
    </ul>
    </details>

 	- ### 长度  多少位 最小值情况 长度 是什么的长度
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> UDP长度占16位</li>
    <li style="color: blue;"> 最小8B 也就是没有数据</li>
    <li style="color: blue;"> 长度 是 首部和数据</li>
    </ul>
    </details>

 	- ### 检验和  作用是什么 出错了如何处理 如果不需要写什么  多少位

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 为了检测UDP数据报在传输过程中是否出错</li>
    <li style="color: blue;"> 如果有就丢弃</li>
    <li style="color: blue;"> 如果不需要 就填写全0</li>
    <li style="color: blue;"> 占16位</li>
    </ul>
    </details>

  - ## UDP检验和 检验的内容是什么 伪首部的内容 计算的时候 检验和填写什么 如果不是数据部分偶数怎么办  不向下传递什么 检验和 通过什么计算 写入检验和的是结果的什么 接收方如何比对 回卷的概念 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 检验的内容是 伪首部和数据部分 </li>
    <li style="color: blue;"> 计算的时候 检验和填写 全0 </li>
    <li style="color: blue;"> 如果不是数据部分偶数 要在数据末尾添加0 让数据达到偶数</li>
    <li style="color: blue;"> 不向下传递 伪首部 和 填充的0</li>
    <li style="color: blue;"> 通过二进制反码计算出16字的求和</li>
    <li style="color: blue;"> 求和结束后 再取反码写入检验和</li>
    <li style="color: blue;"> 接收方 接收到数据后 把数据和伪首部再次进行 取反码求和  如果结果是全1 那么就是对的</li>
    <li style="color: blue;"> 回卷就是 如果最高位相加后有进一 那么就需要在最后得到的结果最低位+1</li>
    </ul>
    </details>
    
  - ## UDP检验和计算过程是什么 接收方如何计算验证
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 如果有3个16位 那么 首先把2个16位求和 </li>
    <li style="color: blue;"> 如果最高位进位 那么就需要回卷操作 得到2个求和结果</li>
    <li style="color: blue;"> 把2个求和结果与第三个相加 同样如果进位就回卷 得到最后结果</li>
    <li style="color: blue;"> 最后结果取 反码填入检验和</li>
    <li style="color: blue;"> 检验方 就是计算4个16位 （3个16位的内容 和 1个16位的检验和）</li>
    <li style="color: blue;"> 4个求和  得到最后结果 全1 就代表无差错</li>
    </ul>
    </details>



- # TCP数据报 
  - ## TCP在什么环境上维持什么服务 TCP是广播的还是点对点的 发送缓存存储什么 接受缓存存储什么

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> TCP在 不可靠的IP数据报上 维持可靠的数据传输 </li>
    <li style="color: blue;">  TCP是点对点的</li>
    <li style="color: blue;"> 发送缓存存储 发送方TCP准备发送的数据 发送放已经发送但是还没有确认的数据</li>
    <li style="color: blue;"> 接受缓存存储 按序到达 但是还没有被应用程序接受的数据 不按序到达的数据</li>
    </ul>
    </details>

  - ## TCP报文段 
    - ### 最短报文段大小是多少

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> TCP 首部固定20字节 后续可以添加 4N的可变首部</li>
    </ul>
    </details>

 	- ### 源端口和目的端口  多少位
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 各占2B</li>
    </ul>
    </details>

 	- ### 序号 占多少位 给什么标记序号 

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 序号占4B</li>
    <li style="color: blue;"> 我们使用seq标识 为数据传输的每个字节编号 并且标识当前数据发送的第一个字节序号是什么</li>
    </ul>
    </details>

 	- ### 确认号 定义是什么 代表什么 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 序号占4B</li>
    <li style="color: blue;"> 我们使用ack标识 认为是对ack-1 数据的确认 也代表 希望下一次的seq序号为 ack </li>
    </ul>
    </details>

 	- ### 数据偏移 是什么的数据偏移 计算单位是多少 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 数据偏移是 首部的数据偏移</li>
    <li style="color: blue;"> 这里说明 TCP报文的数据的开始 距离 TCP报文段开始多元</li>
    <li style="color: blue;"> 计算单位是 4B</li>
    </ul>
    </details>

 	- ### 保留 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 无用 设置为0</li>
    </ul>
    </details>

 	- ### URG 定义是什么 做什么用  要配合什么使用
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> URG是紧急位 代表紧急指针字段有效</li>
    <li style="color: blue;"> 希望系统快速处理当前数据</li>
    <li style="color: blue;"> 只有配合 紧急指针字段 才有用</li>
    </ul>
    </details>

 	- ### ACK 定义是什么 做什么用 

    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> ACK是确认位 只有在ACK=1的时候 确认号字段才有效</li>
    <li style="color: blue;"> TCP要求 建立连接后 ACK均设置为1</li>
    </ul>
    </details>

 	- ### PSH 定义是什么 做什么用 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 如果希望输入一个命令后立马得到响应 发送方就PSH设置为1</li>
    <li style="color: blue;"> 接收方收到PSH为1 就快速上传 而不用等到缓冲区填满</li>
    </ul>
    </details>

 	- ### RST 定义是什么 做什么用 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> RST 复位位 当RST设置为1 代表当前TCP连接存在重大错误 必须释放连接 重新建立</li>
    <li style="color: blue;"> 同时可以用于拒绝非法报文</li>
    </ul>
    </details>

 	- ### SYN 定义是什么 做什么用 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> SYN  同步位 SYN=1 代表当前报文是一个 请求连接 接受连接报文</li>
    <li style="color: blue;"> 在建立连接的时候使用</li>
    </ul>
    </details>

 	- ### FIN 定义是什么 做什么用 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> FIN 终止位 FIN=1 要求释放单向发送连接</li>
    <li style="color: blue;"> 一方FIN=1释放后 另一方依旧可以发送数据</li>
    </ul>
    </details>

 	- ### 窗口 多少位 作用是什么 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 2B </li>
    <li style="color: blue;"> 窗口值告诉对方 从本报文确认号算起 接收方允许对方发送的最大数据量是多少</li>
    </ul>
    </details>

 	- ### 检验和  多少位 计算包括什么 如何计算
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 2B </li>
    <li style="color: blue;"> 计算 首部和数据 计算方法和UDP一样</li>
    </ul>
    </details>

 	- ### 紧急指针 什么时候有效 窗口为0怎么办
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 只在URG=1的时候有效 </li>
    <li style="color: blue;"> 代表当前数据报 紧急数据的字节数</li>
    ‘<li style="color: blue;"> 如果当前窗口值 =0 依旧可以发出 紧急报文</li>
    </ul>
    </details>

 	- ### 选项 MSS最长多少B 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> MSS 是 数据的最大长度 </li>
    </ul>
    </details>

 	- ### 填充 

- # TCP连接管理 
  - ## 三次握手 开始的时候两者处于什么阶段 服务器开启服务后呢 后续
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 首先 用户和服务器 都属于CLOSED 阶段 </li>
    <li style="color: blue;"> 服务器开启服务后 处于 LISTEN 阶段 也就是监听 </li>
    <li style="color: blue;"> 用户请求TCP服务 发送 SYN=1 seq=x 进入 SYN-SENT 阶段</li>
    <li style="color: blue;"> 服务器接受到后发送  SYN=1 ACK=1 ack=x+1 seq=y 这两个都不允许携带数据 但是依旧浪费一个序号 进入SYN-RCVD</li>
    <li style="color: blue;"> 用户 发送 ACK=1 ack = y+1 seq = x+1 这个时候 可以允许携带数据 也可以不带数据 如果不携带数据 那么就不消耗序号 也就是下一个传输 seq依旧是x+1 这个时候进入了 ESTAB-LISHED 阶段</li>
    <li style="color: blue;"> 服务器接受到此报文后 也进入了  ESTAB-LISHED 阶段</li>
    <li style="color: blue;"> 后续就是 用户可以对服务器发送数据传输</li>
    </ul>
    </details>


  - ## 连接的释放 对应时刻 客户机的状态 对应时刻 服务器发送的状态 MSL的定义 客户需要等待多久才进去closed  从客户发送FIN算起 客户释放最短时间 服务器释放最短连接时间各自多少 保活计时器的作用是什么 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 首先 用户和服务器 都属于ESTAB-LISHED 阶段 </li>
    <li style="color: blue;"> 某一时刻 用户不需要再发送信息了 于是发送 FIN=1 squ =u  此报文即使不携带数据也要消耗一个序号 进入  FIN-WAIT-1 阶段 </li>
    <li style="color: blue;"> 服务器收到后 返回对此报文的确认 ACK=1 ack = u+1 seq=v 这个时候 用户和服务器的单向连接释放了 但是服务器依旧可以给用户发送信息 进入 CLOSE-WAIT阶段</li>
    <li style="color: blue;"> 用户收到 服务器发送的确认后 进入 FIN-WAIT-2 阶段 等待服务器与用户的连接释放</li>
    <li style="color: blue;"> 服务器数据传输阶数 也对用户发送 FIN=1 ACK=1 seq =w ack =u+1 终止连接 进入 LAST-ACK 阶段</li>
    <li style="color: blue;"> 用户收到保卫呢 返回对终止的确认 ACK=1 seq=u+1 ack = w+1 进入 TIME-WAIT阶段 等待2MSL</li>
    <li style="color: blue;"> 服务器收到确认后关闭服务进入 CLOSED阶段</li>
    <li style="color: blue;"> 用户等待2MSL后 也进入CLOSED阶段</li>
    <li style="color: blue;"> 如果在用户发出终止的时候 服务器也终止 （从用户发出终止开始） 1RTT+2MSL</li>
    <li style="color: blue;"> 服务器在发出终止到关闭 （从用户发出终止开始） 1.5RTT</li>
    <li style="color: blue;"> 服务器 设置保活计时器 确保用户长时间没有发送连接 服务器可以终止服务 75s发送一个探测 如果10次探测后依旧没有反应 就断开</li>
    </ul>
    </details>
    
  - ## 重传 
    - ### 导致TCP重传的事件是什么   RTT是什么  RTTS是什么   RTO是什么 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> TCP 在超时和遇见冗余ACK的时候 会进行重传</li>
    <li style="color: blue;"> RTT是一个报文的往返实践 </li>
    <li style="color: blue;"> RTTS是TCP维护的一个加权平均往返时间 会随着 RTT样本变化而变化 </li>
    <li style="color: blue;"> RTO是 超时重传时间</li>
    </ul>
    </details>
    
    - ### 冗余ACK的定义是什么 什么时候发送一个冗余ACK 接收方接收到多少冗余ACK就重传这个技术叫什么
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 冗余ACK是为了发送方能够快速发送 而不用等待超时计数器 要求接收方接受到比期望序号大的报文的时候 就发送一个冗余ACK</li>
    <li style="color: blue;"> 如果发送方 发送了 12345 个片段 2在传输的时候丢失 那么接收方无法发送ack确认  </li>
    <li style="color: blue;"> 后续 345 安全到达 那么在对345的确认的时候 一起发送 对2的冗余ACK  </li>
    <li style="color: blue;"> 接收方 收到三个对2号的冗余ACK 就立马重新传输2号 而不是等待超时</li>
    </ul>
    </details>
    

- # TCP流量控制 
  - ## 流量控制的定义是什么 TCP使用什么方式进行流量控制 rwnd的定义 单位是什么
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> TCP的流量控制 控制发送方传输数据的速率 说明后续还接受多少数据量</li>
    <li style="color: blue;"> TCP通过滑动窗口机制进行流量控制  </li>
    <li style="color: blue;"> rwnd 是接收方的一个接受窗口 单位是B  </li>
    <li style="color: blue;"> 注意 紧急报文 在窗口为0 的情况下依旧可以发出</li>
    </ul>
    </details>
    
  - ## 流量控制的过程 零窗口探测报文
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 建立连接的时候 B和A说 我的rwnd为400 也就是B还可以接受400B的数据</li>
    <li style="color: blue;"> 那么 A传输 三个报文 分别 seq为 1 101 201 其中 201丢失 此时A传输了 300B  </li>
    <li style="color: blue;"> 接收方对 ack=201 进行确认 代表201 之前的都收到了 希望下次收到 201 开头 这里是一个 冗余ACK 并且继续告知 rwnd =300  说明现在接收方现在还允许接受 300B </li>
    <li style="color: blue;"> 发送方此时 发送缓存中 还有seq = 201 并且接收方还可以300B 那么 发送方还可以发送200B 于是发出 301 401 停止发送</li>
    <li style="color: blue;"> 发送方 201 超时了 于是 超时重传201 的数据 这个201是在发送方的发送缓存中的 认为是300B的一个 所以合法</li>
    <li style="color: blue;"> 接收方 对 501 进行 ack 代表下次希望收到501开头 也就是对前面所有数据进行确认 rwnd设置为100 说明还允许发送100B</li>
    <li style="color: blue;"> 发送方收到ack后 发送新的100B数据 也就是 seq=501</li>
    <li style="color: blue;"> 服务器 发送ack=601 rwnd设置为0 此时进入静默 不再发送数据</li>
    <li style="color: blue;"> TCP维持一个零窗口探测报文  每发送方发送rwnd=0的时候 就启动计时器 超时 发送一个零窗口探测报文 如果窗口依旧设置为0 那么重新设置 </li>
    </ul>
    </details>
    

- # TCP拥塞处理 定义是什么 TCP的拥塞处理算法有哪些 cwnd的定义是什么 发送方cwnd的变化原则是什么 发送窗口的上限取决于什么
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 整个网络随着发送数据增多 吞吐量变少的时候 就说明拥塞了 TCP需要动态调整</li>
    <li style="color: blue;">TCP对于拥塞控制的算法有 慢开始 拥塞避免 快重传 快恢复  </li>
    <li style="color: blue;"> cwnd的定义是 发送方的 拥塞窗口 需要动态变化</li>
    <li style="color: blue;"> 如果网络还没有拥塞 按照算法 开始变大 让更多数据发送出去 提高利用率 只要出现拥塞 那么就减少 缓解拥塞</li>
    <li style="color: blue;"> 发送方发送数据 受到 rwnd的约束 又受到 cwnd的限制 所以窗口选择 min{rwnd, cwnd }</li>
    </ul>
    </details>
    

  - ## 慢开始算法  具体流程 ssthresh的定义是什么 当cwnd增长到ssthresh的时候策略是什么 拥塞避免算法流程
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 慢开始 初始 cwnd=1 也就是一个MSS 每次增大都 乘2 也就是每经过一次RTT cwnd就x2</li>
    <li style="color: blue;">ssthresh 叫做 慢开始门限 如果 cwnd *2 >=  ssthresh 那么这次的cwnd设置为ssthresh的大小</li>
    <li style="color: blue;"> 当cwnd增长到ssthresh的时候 使用拥塞避免算法</li>
    <li style="color: blue;"> 拥塞避免算法 每一次RTT都增加1 也就是线性增加</li>
    </ul>
    </details>
     
  - ## 在出现网络拥塞的处理  ssthresh的不能小于多少 网络拥塞的判断依据是什么 如果 cwnd 为8 ssthresh为 12 下一次的拥塞窗口为多少 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 无论是在 慢开始或者拥塞避免算法过程中 如果遇见网络拥塞 统一 把 cwnd设置为1 ssthresh设置为出现拥塞的cwnd的一半 但是不能小于2</li>
    <li style="color: blue;"> 拥塞也就是 发送方 无法按时接收到 ACK</li>
    <li style="color: blue;">如果 cwnd 为8 ssthresh为 12 下一次的拥塞窗口为 min{cwnd*2 , ssthresh} = 12</li>
    </ul>
    </details>
    
  - ## 为什么要提出快重传与快恢复 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 有的时候 并不是网络整体出现拥塞 而是个别报文存在问题 如果使用慢开始 就浪费资源 所以使用快恢复</li>
    </ul>
    </details>
    
  - ## 快重传 
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 也就是收到3个冗余ACK 就重传 </li>
    </ul>
    </details>
    
  - ## 快恢复  什么时候要快恢复  如何调整
    <details>
    <summary style="font-weight: bold; color: #007bff;">展开答案</summary>
    <ul>    <li style="color: blue;"> 发送方接受到3 个 冗余ACK的时候 执行快恢复算法 </li>
    <li style="color: blue;"> 把ssthresh设置为当前 cwnd的一半 但是cwnd设置为的是出现3个冗余ACK的cwnd时候的一半 也就是更新后ssthresh = cwnd </li>
    <li style="color: blue;"> 随后直接执行 拥塞避免算法 </li>
    </ul>
    </details>
    
