之前我们学习了操作系统的发展过程 下面按照多道批处理系统学习 操作系统的运行过程中的内容

# 处理器运行模式

我们说过 OS提供 用户和 编程人员接口 但是有些命令 我们希望只有OS自己可以调用也就是系统开发人员 如果给 用户或者邪恶的编程人员 会导致系统出现问题

所以对于CPU执行的代码 我们分为 特权指令和非特权指令

## 特权指令

不允许用户调用 如果用户强行调用 输出中断

常见的特权指令有：IO 关中断 内存清空 读取内存保护的上下界寄存器 修改程序状态字寄存器等

## 非特权指令

用户和普通编程人员可以调用的 不可以直接访问系统软硬件 只可以访问当前用户的地址

对于运行特权和非特权的情况 我们还可以分为 目台（用户态）和管态（内核态）

## 用户态

用户在执行非特权指令的时候 我们认为CPU处于 用户态

## 核心态

操作系统或者系统编程人员执行特权指令的时候 可以认为 CPU处于核心态

# 内核以及运行内容

内核我们可以看作是操作系统最底层的 一切特权指令都在操作系统内核进行 可以看作是裸机上的第一个软件 具有下面的管理内容

## 时钟管理

PC一切内容依靠内部发射的时钟（可以看作是一个周期脉冲）通过脉冲 各个部件可以识别当前需要做什么 从而让PC 有序安全的运行

## 中断管理

可以看作 多道批处理 以及后续操作系统的 核心功能 只有中断处理了 才可以实现OS的并行和共享

## 原语

是一个不可以被打断的 需要一气呵成执行完毕的代码 我们之前知道 CPU运行过程中 可以被打断 但是如果CPU当前执行的是原语 那么需要一次性执行完毕 

# 中断与异常

这里是OS的核心功能 我们之前介绍了 核心态和用户态 CPU如何在这两个状态中切换 就出现了问题

中断是通过 硬件实现的

## 中断

我们可以理解中断也叫做外中断 这和CPU无关 例如发生电源断电 IO等

中断包含 可屏蔽中断（也就是优先级可以排序的中断）和不可屏蔽中断（非常紧急）

## 异常

异常是和CPU有关的 他是不可以被屏蔽的 如果CPU执行出现异常 那么需要立马处理 我们也把异常看作是内中断

### 故障

一般是 代码的问题 例如非法除0 执行特权指令等

### 自陷

这里 是 CPU 从用户态 转化为 核心态的唯一方法 我们之前知道 IO是属于特权指令的 如果用户需要输入或者输出内容 就需要OS的帮助 作业通过自陷指令要求CPU提供服务 所以我们可以发现 自陷指令也是 非特权指令

### 终止

这是CPU无法继续执行的硬件问题

![image-20251023151323658](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251023151323658.png)

# 中断异常处理过程

这里大概描述一下处理过程

CPU执行到i指令后 出现异常或者有一个中断信号 CPU打断当前进程 转到对应中断处理程序中 按照中断处理程序 处理问题 如果可以处理 就返回到当前指令i 或者i+1 否则就终止

这里是最简单 没有细节的处理过程 后续还会学到 如何找到 中断处理程序 以及其他内容

# 系统调用

系统调用可以理解为 OS 提供给编程人员的接口 可以看作是一个不可修改的 公共程序 

只要是和 共享资源有关的操作 就需要通过系统调用 对 OS提出服务请求 让OS代替完成 并且返回结果

## 系统调用执行过程

例如C语言的Printf 我们可以看作是 调用系统输出

首先把 printf要用的参数压入栈中 call 系统调用陷入指令 这个时候 CPU从用户态转为内核态 通过硬件和OS打断当前执行的内容 并且保存执行现场（PC PSW 和 通用寄存器内容） 然后CPU分析系统调用程序的地址 转去执行 执行完毕后 要么返回之前程序 要么重新调度新的程序

执行完毕后 CPU又会变为用户态

![image-20251023151904955](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251023151904955.png)